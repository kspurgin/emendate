= Development notes

Notes on things still to be implemented, things to fix, etc.

== Output - differences from Timetwister

`Timetwister.parse` returns an `Array` of ``Hash``es, with one `Hash` per date or date range identified in the parsed date `String`:

----
r = Timetwister.parse('[1997, 1999]')
 => [{:original_string=>"[1997", :index_dates=>[1997], :date_start=>"1997", :date_end=>"1997", :date_start_full=>"1997-01-01", :date_end_full=>"1997-12-31", :inclusive_range=>nil, :certainty=>"inferred", :test_data=>"70"}, {:original_string=>" 1999]", :index_dates=>[1999], :date_start=>"1999", :date_end=>"1999", :date_start_full=>"1999-01-01", :date_end_full=>"1999-12-31", :inclusive_range=>nil, :certainty=>"inferred", :test_data=>"70"}]
----

The original string is split among the date hashes if there are multiple dates.

Each date hash has:

- `:certainty` - a string
- `:inclusive_range` - true or nil
- `:date_start` and `:date_end`, which are at the granularity level of the date given (no assumed values)
- `:date_start_full` and `:date_end_full`, which are ISO8601 representations in YYYY-MM-DD format, assuming values where needed
- `:index_dates` - an Array of each year encompassed by the provided date range
- `:test_data` - not documented, used to tie result to a test example

If multiple certainty values could apply, Timetwister only returns one:

----
r = Timetwister.parse('[circa 1920?]')
 => [{:original_string=>"[circa 1920?]", :index_dates=>[1920], :date_start=>"1920", :date_end=>"1920", :date_start_full=>"1920-01-01", :date_end_full=>"1920-12-31", :inclusive_range=>nil, :certainty=>"questionable", :test_data=>"70"}]
----

Emendate will return a `Hash` with the following keys:

- `:original_string` - the full original string passed in for parsing
- `:errors` - will only be present if `:result` is empty. Will give some indication why parsing failed.
- `:warnings` - may be present if `:result` is populated.  
- `:result`, an `Array` the same as TimeTwister's result except for the following differences:

- Individual date `Hash` does not contain an `:original_string` value, at least initially, given that the original string was not split up into discrete date values.
- Only `:date_start_full` and `date_end_full` are initially provided.
- `:index_dates` is not initially provided, given I don't currently have a direct use case for it
- `:test_data` is not included
- `:certainty` is an array of applicable certainty values: approximate, inferred, uncertain

If the date cannot be parsed, Timetwister returns a date hash with all values empty or nil except `:original_string`:

----
r = Timetwister.parse('before 1920')
 => [{:original_string=>"before 1920", :index_dates=>[], :date_start=>nil, :date_end=>nil, :date_start_full=>nil, :date_end_full=>nil, :inclusive_range=>nil, :certainty=>nil}]
----

In this case Emendate will return an empty `Array` for `:result`.

== To-do
=== option for handling output of EDTF when only year or year/month are known

==== one configurable option for month level
Example: 2004

If option is `none` (default), output `2004`

If option is `unspecified_digits`, output `2004-XX`

If option is a number (say 4), output `2004-04`

==== one configurable option for day level
Example: April 2004

If option is `none` (default), output `2004-04`

If option is `unspecified_digits`, output `2004-04-XX`

If option is a number (say 7), output `2004-04-07`

==== interactions

If month is none, only none is valid for day. Any other value for day will be ignored.

Otherwise, you can set them independently:

Example: 2004

month: unspecified_digits, day: 17 = 2004-XX-17

month: 10, day: unspecified_digits = 2004-10-XX

== Notes

Islandora has no built-in date functionality. It uses the pre-parsed values in MODS (I7) or Drupal fields (I8), so we can basically do whatever with the date parsing.

=== ISO8601 and BCE

From https://en.wikipedia.org/wiki/ISO_8601#Years

ISO 8601 prescribes, as a minimum, a four-digit year [YYYY] to avoid the year 2000 problem. It therefore represents years from 0000 to 9999, year 0000 being equal to 1 BC and all others AD. However, years prior to 1583 are not automatically allowed by the standard. Instead "values in the range [0000] through [1582] shall only be used by mutual agreement of the partners in information interchange."

=== Early/mid/late season

to do

=== Early/mid/late month

to do

=== Early/mid/late decade

Examples: Early 1990s, mid-1990s, late 1990s

bThere is no standard agreement anywhere about what years of the decade constitute early, mid, and late. Preferences for breaking this up include: 3-4-3 and 4-2-4.

CollectionSpace's date parser handles this as follows:

early 1990s = 1990-1993

mid 1990s = 1994-1996

late 1990s = 1997-1999


This is different than what TimeTwister returns:

early 1990s = 1990-1995

mid 1990s = 1993-1998

late 1990s = 1995-1999

For a cohesive user experience between migration/batch import and use of CollectionSpace UI, we need to do what CS does.

=== Early/mid/late year

Examples: Early 2020, mid-2020, late 2020

In Islandora we'll have to feed it pre-parsed values in MODS or Drupal fields.

CollectionSpace parses these as follows, so we will go with that as the requirement:

early 2020 = 2020-01-01 to 2020-04-30
mid 2020 = 2020-05-01 to 2020-08-31
late 2020 = 2020-09-01 to 2020-12-31

=== Seasons (textual)
Go with what CS does.

*Winter 2020*

CS = 2020-01-01 - 2020-03-31

TT = 2020-01-01 - 2020-03-20

*Spring 2020*

CS = 2020-04-01 - 2020-06-30

Timetwister = 2020-03-20 - 2002-06-21

*Summer 2020*

CS = 2020-07-01 - 2020-09-30

TT = 2020-06-21 - 2020-09-23

*Fall 2020*

CS = 2020-10-01 - 2020-12-31

TT = 2020-09-23 - 2020-12-22


=== Before/after dates

Example: before 1750

Since CollectionSpace is museum oriented, it's possible we need to support *really* old dates.

Cspace only parses a date like this into the latest date. Earliest/single date is nil. So, initially we will just return a single date value (not an inclusive range) (i.e. 1750-01-01), with "before" certainty value.

Example: after 1750

Since the latest date is TODAY, we have an end point and can return the inclusive range. Certainty "after" is assigned to the given date. Certainty "before" is assigned to the current date.

=== Centuries

example: 19th century

CS = 1801-01-01 - 1900-12-31

TT = 1800-01-01 - 1899-12-31

Because of the difference in years used in setting ranges, I'm going to go with CS and not compare what early/mid/late values are set.

`early/mid/late 18th century`

named, early = 1701-01-01 - 1734-12-31

named, mid = 1734-01-01 - 1767-12-31

named, late = 1767-01-01 - 1800-12-31

`early/mid/late 1900s or 19XX`

other, early = 1900-01-01 - 1933-12-31

other, mid = 1933-01-01 - 1966-12-31

other, late = 1966-01-01 - 1999-12-31
