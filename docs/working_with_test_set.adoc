:toc:
:toc-placement!:
:toclevels: 4

ifdef::env-github[]
:tip-caption: :bulb:
:note-caption: :information_source:
:important-caption: :heavy_exclamation_mark:
:caution-caption: :fire:
:warning-caption: :warning:
endif::[]

= Working with the test set

toc::[]

== Test set CSV

This file is found at https://github.com/kspurgin/emendate/blob/main/spec/support/examples.csv[`spec/support/examples.csv`].

IMPORTANT: When you open this file with an application, it is very important that it treat all fields as text values. Otherwise the application may try to be "smart" and will mess up date values trying to convert them.

The CSV represents date patterns (`examplepattern`) exemplified by concrete date strings (`examplestring`), and expectations about how `emendate` will process the date strings, given the `options` provided.

NOTE: If `options` is empty, `emendate` applies https://github.com/kspurgin/emendate/blob/main/docs/options.adoc[default options].

Rows with the same `test_string` and `test_options` value are said to have the same "test fingerprint". These rows belong to one test, which is expected to output multiple dates in the `Emendate::Result`. The expected order of dates is expressed in the `dateval_occurrence` field, with count starting at 0.

The examples are tagged with `tags_date_type` tags and `tags_data_set` tags. You can get information and run tests on subsets of the test set by selecting only examples having certain tags. There are two types of tags to facilitate building up a robust test set to support future development, while also focusing on immediately implementing only the patterns required for a given project. (I can add a bunch of examples I know will currently fail, to serve as a development roadmap. But then I can tag some of them with an active data set I'm working on, so I can test whether the app is ready for use converting project dates or not.)

The remaining columns record expected values for use in tests. 

See Tests and expectaions below for more info.

== Tests and expectations

=== Columns/tests
Columns beginning with `date_` test expectations about the value(s) that will be returned in the `Emendate::Result.dates` Array. One row is provided per expected `@dates` Array element.

Columns beginning with `result_` test expectations about other parts of the `Emendate::Result` object.

Columns beginning with `translation_` test expectations about the results of `Emendate.translate`, with the remainder of the column name passed in as the `target_dialect` option value.

IMPORTANT: There are some columns and values for tests that are not yet implemented.

=== Values and lack thereof
If a test expectation column is blank, this simply means a test value has not yet been provided. Tests will not be run against empty expectations.

If we want to test that the returned value is nil, we enter `nilValue` in the expectation field.

We can also enter `today` as an expectation, to stand in for the current date in tests. This is helpful for open-ended ranges.

=== Runnable tests

To be runnable, a test must be implemented, and all expectations required to run the test must be present.

For example, as of 2022-05-24, there is a `date_start` column, but no `test_date_start` test has been implemented. Even though some rows have data in the `date_start` column, `test_date_start` is _not_ a runnable test.

`test_date_start_full` is implemented. If a single `Emendate::Result.dates` element is expected, and the `date_start_full` column contains a value, then `test_date_start_full` is a runnable test for that test_fingerprint. If multiple `Emendate::Result.dates` elements are expected, and the `date_start_full` column contains a value in the row for each expected date, then `test_date_start_full` is a runnable test for that test_fingerprint. If multiple `Emendate::Result.dates` elements are expected, but the `date_start_full` column is not populated for each expected date, then `test_date_start_full` is _not_ a runnable test for that test_fingerprint.

Tests that are not runnable due to missing expectation data will be skipped.

=== `test_processing`

This test determines if Emendate can successfully process a given test fingerprint without throwing an error.

This test is not run manually, and does not show up in the list of runnable tests for and example set; however, it is always run first when you kick off tests. This is because it makes no sense to test that the values for a test fingerprint are as expected, if the test data cannot even be processed.

== Code examples

The following examples assume you cloned the repo into a folder called `emendate` and have done:

----
cd emendate
bin/console
----

=== Info about the entire test set

.List all unique date string values in the entire test set
[source, ruby]
----
Emendate.example_strings
----

Test fingerprint is the combination of the `test_string` and `test_options` fields. The string and options values are separated by ` ||| `.

.List all unique test fingerprints (test_string + test_options) in the entire test set
[source, ruby]
----
Emendate.example_fingerprints
----

.List all unique abstract date patterns in the entire test set
[source, ruby]
----
Emendate.example_patterns
----

.List all tags used in the entire test set
[source, ruby]
----
Emendate.example_tags
----

TIP: The type of tag (`data_set` or `date_type`) is given in parentheses after the tag value. The tag type is determined by the test CSV column (`tags_data_set` or `tags_date_type`) in which the tag is recorded. **Do not include the parenthetical tag type when using the tag to https://github.com/kspurgin/emendate/blob/main/docs/working_with_test_set.adoc#selecting-examples-by-tag[select an example set]!**

You can also get lists of each type of tag:

[source, ruby]
----
Emendate.example_data_set_tags
----

or

[source, ruby]
----
Emendate.example_date_type_tags
----

=== Creating an example set
You will need to create an example set before running tests on the examples or generating any other info from them.

Assign the example set to a variable (we are using `ex` as the variable name in the examples below), so you can reuse the set.

==== All examples

.Create a test set of all examples in the CSV.
[source, ruby]
----
ex = Emendate.all_examples
 => Emendate::Examples::ExampleSet: 204 examples from 248 rows (data_sets: , date_types: )
----

==== Selecting examples by tag

TIP: This is where the parenthetical tag type info you can get via `Emendate.example_tags` comes in handy.

NOTE: The exact counts in the examples below will change as the test set evolves.

.Examples expressing approximate dates
[source, ruby]
----
ex = Emendate.examples_with(date_type: 'approximate')
 => Emendate::Examples::ExampleSet: 41 examples from 47 rows (data_sets: , date_types: approximate)
----

.Examples from the `ba` dataset
[source, ruby]
----
ex = Emendate.examples_with(data_set: 'ba')
 => Emendate::Examples::ExampleSet: 38 examples from 45 rows (data_sets: ba, date_types: )
----

.Examples from the `ba` dataset expressing decades
[source, ruby]
----
ex = Emendate.examples_with(data_set: 'ba', date_type: 'decades')
 => Emendate::Examples::ExampleSet: 4 examples from 6 rows (data_sets: ba, date_types: decades)
----

You can use multiple tags of a given type to select. Separate the tag values with `;`.

IMPORTANT: Criteria are always Boolean AND-ed when selecting examples.

.Examples in both the `ba` and `ncm` datasets
[source, ruby]
----
ex = Emendate.examples_with(data_set: 'ba;ncm')
 => Emendate::Examples::ExampleSet: 1 examples from 1 rows (data_sets: ba;ncm, date_types: )
----

=== Info about an example set

NOTE: The following examples assume you have created an `ExampleSet` in a variable named `ex`. See the above section.

.List the test strings in the set
[source, ruby]
----
puts ex.get_example_data(data_method: :test_string)
----

.List the abstract test patterns in the set, with the strings of each pattern listed below
[source, ruby]
----
puts ex.get_example_data(data_method: :test_pattern)
----

.List the strings in the test set, with the `test_options` provided for each listed below
[source, ruby]
----
puts ex.get_example_data(data_method: :fingerprint)
----

.List runnable tests for the example set
[source, ruby]
----
puts ex.runnable_tests
----

=== Advanced processing info about an example set

NOTE: The following will probably make more sense if you have read https://github.com/kspurgin/emendate/blob/main/docs/processing.adoc[How Emendate processes date strings].


This will output all unique type patterns being generated from the example strings:

`Emendate.unique_type_patterns`

Beneath each type pattern is a list of the original strings that have ended up with this pattern.

Running the command as shown above shows you all segment types, for all strings, and shows you the final result of the `SegmentSet` processing, with default configuration.

Of course, there are other options!

To see only the ``Segment``s that are/can be parts of actual dates, from just after date part tagging, only for examples with the inferred tag:

`Emendate.unique_type_patterns(type: :date, stage: :segment_dates, tag: :inferred, options: {ambiguous_month_day: :as_day_month})`

Note that the options need to be wrapped in curly braces here.

Also note that `stage` indicates the processing step that your desired input feeds into. Processing moves from `tag_date_parts` to `segment_dates`, so if you want see the results of date part tagging, the stage the data is ready for is `segment_dates`. 


== Date pattern conventions

`#`:: digit in an unambiguous (given assumptions made) number
`0`:: literally one zero
`00`:: literally two zeroes
`@`:: digit in an ambiguous number (i.e. it's not clear whether it's a month or day, etc.)
`MON`:: abbreviated alphabetical month name
`MONTH`:: alphabetical month name
`ERA`:: BCE, AD, CE, BC, etc.
`SEASON`:: alphabetical season term
`ORD`:: alphabetical ordinal indication, such at st, rd, etc.
lowercase letters:: themselves, literally
`.,/-&?() []`:: themselves, literally (same for spaces)


+++<s>+++

[NOTE]
====
The following will make more sense if you have read https://github.com/kspurgin/emendate/blob/main/docs/processing.adoc[How Emendate processes date strings].
====

This will output all unique type patterns being generated from the example strings:

`Emendate.unique_type_patterns`

Beneath each type pattern is a list of the original strings that have ended up with this pattern.

Running the command as shown above shows you all segment types, for all strings, and shows you the final result of the `SegmentSet` processing, with default configuration.

Of course, there are other options!

To see only the ``Segment``s that are/can be parts of actual dates, from just after date part tagging, only for examples with the inferred tag:

`Emendate.unique_type_patterns(type: :date, stage: :segment_dates, tag: :inferred, options: {ambiguous_month_day: :as_day_month})`

Note that the options need to be wrapped in curly braces here.

Also note that `stage` indicates the processing step that your desired input feeds into. Processing moves from `tag_date_parts` to `segment_dates`, so if you want see the results of date part tagging, the stage the data is ready for is `segment_dates`. 
+++</s>+++
