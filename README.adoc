= Emendate

Lexer, parser, and manipulator for messy date metadata values

== Installation

Add this line to your application's Gemfile:

--------------------------------------------------
gem 'emendate'
--------------------------------------------------

And then execute:

`$ bundle install`

Or install it yourself as:

`$ gem install emendate`

== Use

You can play with Emendate after installation by doing the following (assuming you cloned the repo into a folder called `emendate`):

----
cd emendate
bin/console
----

The basic command is:

`Emendate.process('early 19th c.')`

As Emendate is still under development, this currently returns a big ProcessingManager object, that is difficult to visually parse.

Assign it to a variable...

`pm = Emendate.process('Early 19th c.')`

...and then look at what specific parts of it you can request:

`pm.instance_variables`

This returns a list of things you can put after `pm.` (remove the `:@`). For example, the normalized version of your original input string:

`pm.norm_string`

You can ignore `:@aasm`, which is internally used for processing.

`:@errors` and `:@warnings` will show any messages in those categories. Errors are problems/issues that can't be handled by Emendate. Warnings are things Emendate handled, but which you might want to review because the input was in some way ambiguous or odd.

The rest contain a representation of the original string at each stage of processing. `:@tokens` always shows the latest stage in processing. For more details on the processing stages and what the data will look like at each stage, see (addlink)


This is not in the list of instance_variables you can call, but will show you if processing finished successfully (`done`) or not (`failed`):

`pm.state`


== Purpose

Legacy metadata contains date data encoded using various standard and semi-standard date-recording conventions, or without any consistent conventions.

Emendate's goal is to parse such date strings and return structured data objects that can be used by other applications to supply consistently formatted date values in metadata or indexes.

The test set of date formats Emendate intends to support can be viewed https://github.com/kspurgin/emendate/blob/main/spec/helpers.rb[here]. Note that formats with an `unparseable` tag are not expected to be supported in any realistic timeframe.

=== My use cases

I am responsible for migrating client data to new systems. The target systems vary in the way date data must be prepared:

- Islandora 7 wants dates encoded in MODS XML
- Islandora 8 wants EDTF strings
- CollectionSpace wants XML like:

[CollectionSpace structuredDate elements, xml]
----
<fieldCollectionDateGroup>
  <scalarValuesComputed>true</scalarValuesComputed>
  <dateEarliestSingleCertainty/>
  <dateEarliestSingleQualifierUnit/>
  <dateDisplayDate>8-11-09</dateDisplayDate>
  <dateLatestScalarValue>2009-08-12T00:00:00.000Z</dateLatestScalarValue>
  <dateEarliestSingleQualifierValue/>
  <datePeriod/>
  <dateLatestEra/>
  <dateEarliestSingleDay>11</dateEarliestSingleDay>
  <dateEarliestSingleQualifier/>
  <dateEarliestSingleYear>2009</dateEarliestSingleYear>
  <dateLatestCertainty/>
  <dateAssociation/>
  <dateLatestDay/>
  <dateEarliestSingleMonth>8</dateEarliestSingleMonth>
  <dateEarliestSingleEra>urn:cspace:core.collectionspace.org:vocabularies:name(dateera):item:name(ce)'CE'</dateEarliestSingleEra>
  <dateLatestYear/>
  <dateLatestQualifierUnit/>
  <dateNote/>
  <dateLatestQualifierValue/>
  <dateLatestQualifier/>
  <dateEarliestScalarValue>2009-08-11T00:00:00.000Z</dateEarliestScalarValue>
  <dateLatestMonth/>
</fieldCollectionDateGroup>
----

I kept running into the same patterns of messy date metadata in the data to be migrated, and found myself re-writing (or seeing that I would need to re-write) the same logic in the migration tooling for each tool I support. So I decided to encapsulate this in Emendate.

=== Relationship with/comparison to other tools

==== Chronic

I was initially using https://github.com/mojombo/chronic[Chronic] in preparation of some date metadata, but it is not at all oriented to the kind of date formats typically found in cutural heritage institution data. Further, it returns just a Ruby `Time` object, which does not support the complex structured information I needed such as: certainty (approximate, uncertain, supplied/inferred date), inclusive ranges/intervals, and dealing with values like "early 19th century" or "before 1672."

==== Timetwister

When I discussed the issues I was facing with my colleague https://github.com/lorawoodford[Lora Woodford], she pointed me to https://github.com/alexduryee/timetwister[Timetwister], developed by New York Public Library. This looked very promising, as it has been developed specifically for cultural heritage institution date data, and it returns a structured data object with the types of data we typically need to represent complex date data in our systems.

At that time, I had gathered 99 test examples of different date formats from client data. (At the time, the set did not include EDTF date patterns or some of the date conventions used in MARC records.

When I ran my examples through Timetwister, 45 of the 99 examples weren't handled as expected (or at all).

At this point, I began to examine the Timetwister codebase, to see if I could contribute back to make it work for a wider range of date formats.

I was discouraged from this approach by finding that much of the parsing is handled by long, complex regular expressions. I immediately saw how some of the stuff in my example set couldn't reasonably be handled that way. I saw there is https://github.com/alexduryee/timetwister/issues/9[an issue from 2016] to add EDTF support, which was still open as of 2021-02-12. There are many reasons why this could still be open, but if you have built up your regexp matching based on some set of initial assumptions, something like EDTF or some of my examples could make it nearly impossible to include them without adding byzantine logical loops and more complexity to already complex and opaque regexes ( really hard to maintain and debug over time), or starting from scratch.

Though the regex approach is common in tools trying to do things like this (I examined several), most of them seem to be attempting to handle a somewhat more standard universe of things than Emendate is.

Faced with trying to contribute back to Timetwister and possibly ending up rewriting much of it, I opted to continue work on Emendate.

==== Others

I also have looked into the following libraries, none of which seemed to cover the entire problem I am trying to solve with Emendate, but all of which have informed the development of Emendate and helped me understand this problem space more fully.

- https://github.com/sul-dlss/parse_date[parse_date from Stanford Digital Library Systems and Services]
- https://github.com/inukshuk/edtf-ruby[edtf-ruby]
- https://github.com/duke-libraries/edtf-humanize[edtf-humanize from Duke University Libraries]
- https://github.com/collectionspace/services/tree/master/services/structureddate/structureddate/src[the structuredDate code and tests for CollectionSpace]

== Limitations

- Does not attempt to deal with any unit of time more specific than day. If given a value such as 1985-04-12T23:20:30Z, it will extract 1985-04-12.






